# using Pkg;
# Pkg.add(["Dates", "DataFrames", "CategoricalArrays", "JDF", "CSV", "TimeZones"])

include("../src/env_config.jl")

"""
Use 'Config' to get canned train, eval, test data.

In future to add new OHLCV data from Binance.
"""
module Ohlcv

using Dates, DataFrames, CategoricalArrays, JDF, CSV, TimeZones, Logging
using ..Config

export readcsv!, write, read!, OhlcvData

mutable struct OhlcvData
    df::DataFrames.DataFrame
    base::String
    qte::String  # instead of quote because *quote* is a Julia keyword
    xch::String  # exchange - also implies whether the asset type is crypto or stocks
    interval::String
end

save_cols = [:opentime, :open, :high, :low, :close, :basevolume]

"Returns an empty dataframe with all persistent columns"
function defaultohlcvdataframe()::DataFrames.DataFrame
    df = DataFrame(opentime=DateTime[], open=Float32[], high=Float32[], low=Float32[], close=Float32[], basevolume=Float32[])
    return df
end

" Returns an empty default crypto OhlcvData with quote=usdt, xch=binance, interval=1m"
function defaultohlcv(base)::OhlcvData
    ohlcv = OhlcvData(defaultohlcvdataframe(), base, Config.cryptoquote, Config.cryptoexchange, "1m")
    return ohlcv
end

basesymbol(ohlcv::OhlcvData) = ohlcv.base
quotesymbol(ohlcv::OhlcvData) = ohlcv.qte
exchange(ohlcv::OhlcvData) = ohlcv.xch
interval(ohlcv::OhlcvData) = ohlcv.interval
dataframe(ohlcv::OhlcvData) = ohlcv.df

function setbasesymbol!(ohlcv::OhlcvData, base::String)
    ohlcv.base = base
end

function setquotesymbol!(ohlcv::OhlcvData, qte::String)
    ohlcv.qte = qte
end

function setexchange!(ohlcv::OhlcvData, exchange::String)
    ohlcv.xch = exchange
end

function setinterval!(ohlcv::OhlcvData, interval::String)
    ohlcv.interval = interval
end

function setdataframe!(ohlcv::OhlcvData, df)
    ohlcv.df = df
end

"""
returns the relative forward/backward looking gain
"""
function relativegain(prices, baseix, gainix)
    gain = (prices[gainix] - prices[baseix]) / prices[baseix]
    # println("forward gain(prices[$baseix]= $(prices[baseix]) prices[$gainix]= $(prices[gainix]))=$gain")
    return gain
end


function addpivot!(df::DataFrame)
    cols = names(df)
    if all([c in cols for c in ["open", "high", "low", "close"]])
        df[:, :pivot] = (df[!, :open] + df[!, :high] + df[!, :low] + df[!, :close]) ./ 4
    end
    return df
end

function addpivot!(ohlcv::OhlcvData)
    addpivot!(ohlcv.df)
    return ohlcv
end

"""
Reads OHLCV data generated by python FollowUpward
"""
function readcsv!(ohlcv::OhlcvData)::OhlcvData
    io = CSV.File(Config.datafile(ohlcv.base * "_OHLCV", "_df.csv"), types=Dict(1=>String, 2=>Float32, 3=>Float32, 4=>Float32, 5=>Float32, 6=>Float32, 7=>Float32))
    df = DataFrame(io)
    df[!, :opentime] = DateTime.(ZonedDateTime.(df[!, :Column1], "y-m-d H:M:s+z"), UTC)
    df = df[!, Not(:Column1)]
    df = df[!, Cols(:opentime, :)]
    df = df[!, save_cols]
    # df = df[!, Not(:opentime)]
    setdataframe!(ohlcv::OhlcvData, df)
    return ohlcv

end

function setsplit()::DataFrame
    io = CSV.File(Config.setsplitfilename())
    iodf = DataFrame(io)
    len = size(iodf, 1)

    df = iodf[!, [:set_type]]
    df[!, :start] = Vector{DateTime}(undef, len)
    df[!, :end] = Vector{DateTime}(undef, len)
    [df[ix, :start] = DateTime.(ZonedDateTime.(String(iodf[ix, :start]), "y-m-d H:M:s+z"), UTC) for ix in 1:len]
    [df[ix, :end] = DateTime.(ZonedDateTime.(String(iodf[ix, :end]), "y-m-d H:M:s+z"), UTC) for ix in 1:len]
    # println(df)
    return df

end

function setassign!(ohlcv::OhlcvData)
    setname = ["NA" for ix in eachrow(ohlcv.df)]

    splitdf = setsplit()
    # display(splitdf)
    sort!(splitdf, [:start, :end])
    sizesplitdf = size(splitdf, 1)
    setix = 1
    opentimes = ohlcv.df[!, :opentime]
    for ix in eachindex(opentimes)
        while (setix <= sizesplitdf) && (splitdf[setix, :end] < opentimes[ix])
            setix += 1
        end
        if (setix <= sizesplitdf) && (splitdf[setix, :start] <= opentimes[ix])
            setname[ix] = splitdf[setix, :set_type]
        end
    end

    setcategory = CategoricalArrays.categorical(setname, compress=true)
    ohlcv.df[!, :set] = setcategory
end

"""
Selects the given columns and returns them as transposed array, i.e. values of one column belong to one sample and rows represent samples.
setname selects one of several disjunct subsets, e.g. :training, : test, as defined in the sets split csv file.
"""
function columnarray(ohlcv::OhlcvData, setname::String, cols::Array{Symbol,1})::Array{Float32,2}
    setassign!(ohlcv)
    gd = groupby(ohlcv.df, [:set])
    subdf = gd[(set=setname,)]
    stackarr = [subdf[:,sym] for sym in cols]
    n = size(stackarr, 1)
    colarray = zeros(eltype(stackarr[1]),(n, size(stackarr[1],1)))
    for i in 1:n
        colarray[i, :] .= stackarr[i]
    end
    return colarray
end

mnemonic(ohlcv::OhlcvData) = ohlcv.base * "_" * ohlcv.qte * "_" * ohlcv.xch * "_" * ohlcv.interval * "_OHLCV"

function write(ohlcv::OhlcvData)
    mnm = mnemonic(ohlcv)
    filename = Config.datafile(mnm)
    # println(filename)
    JDF.savejdf(filename, ohlcv.df[!, save_cols])  # without :pivot
    df = ohlcv.df
    println("saved $filename of $(ohlcv.base) from $(df[1, :opentime]) until $(df[end, :opentime]) with $(size(df, 1)) rows at $(ohlcv.interval) interval")
end

function read!(ohlcv::OhlcvData)::OhlcvData
    mnm = mnemonic(ohlcv)
    filename = Config.datafile(mnm)
    df = DataFrame()
    # println(filename)
    if isdir(filename)
        try
            df = DataFrame(JDF.loadjdf(filename))
            println("loaded OHLCV data of $(ohlcv.base) from $(df[1, :opentime]) until $(df[end, :opentime]) with $(size(df, 1)) rows at $(ohlcv.interval) interval")
        catch e
            Logging.@warn "exception $e detected"
        end
    end
    # display(first(df, 1))
    setdataframe!(ohlcv, df)
    return ohlcv
end

function delete(ohlcv::OhlcvData)
    mnm = mnemonic(ohlcv)
    filename = Config.datafile(mnm)
    # println(filename)
    if isdir(filename)
        rm(filename; force=true, recursive=true)
    end
end

end  # Ohlcv
