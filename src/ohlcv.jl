using DrWatson
@quickactivate "CryptoTimeSeries"

include("../src/env_config.jl")
# import Pkg; Pkg.add(["JDF", "CSV"])

"""
Use 'Config' to get canned train, eval, test data.

In future to add new OHLCV data from Binance.
"""
module Ohlcv

using Dates, DataFrames
using JDF, CSV, TimeZones
using ..Config

export readcsv, write, read

mutable struct OhlcvData
    df::DataFrames.DataFrame
    base::String
end


"""
Reads OHLCV data generated by python FollowUpward
"""
function readcsv(base::String)::OhlcvData
    ohlcv = OhlcvData(DataFrame(), base)
    io = CSV.File(Config.datafile(mnemonic(ohlcv), Config.python, "csv"), types=Dict(1=>String, 2=>Float32, 3=>Float32, 4=>Float32, 5=>Float32, 6=>Float32, 7=>Float32))
    df = DataFrame(io)
    df[!, :timestamp] = DateTime.(ZonedDateTime.(df[!, :Column1], "y-m-d H:M:s+z"), UTC)
    df = df[!, Not(:Column1)]
    df = df[!, Cols(:timestamp, :)]
    # df = df[!, Not(:timestamp)]
    ohlcv = OhlcvData(df, base)
    return ohlcv

end

function setsplit()::DataFrame
    io = CSV.File(Config.setsplitfilename())
    iodf = DataFrame(io)
    df = iodf[!, [:set_type]]
    df.start = DateTime.(ZonedDateTime.(iodf[!, :start], "y-m-d H:M:s+z"), UTC)
    df.end = DateTime.(ZonedDateTime.(iodf[!, :end], "y-m-d H:M:s+z"), UTC)
    # df.timestamp = DateTime.(ZonedDateTime.(df.Column1, "y-m-d H:M:s+z"), UTC)
    # df = df[!, Not(:Column1)]
    # df = df[!, Cols(:timestamp, :)]
    # df = df[!, Not(:timestamp)]
    # ohlcv = OhlcvData(df, base)
    return df

end

function setassign!(ohlcv::OhlcvData)
    setname = ["NA" for ix in eachrow(ohlcv.df)]

    splitdf = setsplit()
    sort!(splitdf, [:start, :end], rev = (false, false))
    nrowsplitdf = nrow(splitdf)
    setix = 1
    timestamps = ohlcv.df[!, :timestamp]
    for ix in eachindex(timestamps)
        while (setix <= nrowsplitdf) && (splitdf[setix, :end] < timestamps[ix])
            setix += 1
        end
        if (setix <= nrowsplitdf) && (splitdf[setix, :start] <= timestamps[ix])
            setname[ix] = splitdf[setix, :set_type]
        end
    end

    setcategory = categorical(setname, compress=true)
    ohlcv.df[!, :set] = setcategory
end

"""
Selects the given columns and returns them as transposed array, i.e. values of one column belong to one sample and rows represent samples.
setname selects one of several disjunct subsets, e.g. :training, : test, as defined in the sets split csv file.
"""
function columnarray(ohlcv::OhlcvData, setname::String, cols::Array{Symbol,1})::Array{Float32,2}
    setassign!(ohlcv)
    gd = groupby(ohlcv.df, [:set])
    subdf = gd[(set=setname,)]
    stackarr = [subdf[:,sym] for sym in cols]
    n = size(stackarr, 1)
    colarray = zeros(eltype(stackarr[1]),(n, size(stackarr[1],1)))
    for i in 1:n
        colarray[i, :] .= stackarr[i]
    end
    return colarray
end

function mnemonic(ohlcv::OhlcvData)
    return ohlcv.base * "_OHLCV"
end

function write(ohlcv::OhlcvData)
    mnm = mnemonic(ohlcv)
    filename = Config.datafile(mnm, Config.julia, "jdf")
    # println(filename)
    JDF.savejdf(filename, ohlcv.df)
end

function read(base::String)::OhlcvData
    ohlcv = OhlcvData(DataFrame(), base)
    mnm = mnemonic(ohlcv)
    filename = Config.datafile(mnm, Config.julia, "jdf")
    # println(filename)
    df = DataFrame(JDF.loadjdf(filename))
    ohlcv = OhlcvData(df, base)
end

end  # Ohlcv
