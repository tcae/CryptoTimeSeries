"""
This module investiagtes the relation of gradient and gains. The assumption was that a steeper gradient correlates with on average higher gains.
The results generated by this module on the data basis of training cryptocurrencies shows that it is in fact exactly the other way around, i.e. the probabilibty of higher gains is with flatter gradients.

The other assumption was that slopes with gain >1% have shortly before their peak the highest gain, which is true for e.g. sinus curves because the regression takes a while to go horizontal.
The assumption was that the gradient with peak is a flat gradient, which is found by going back on the slope looking for the highest actual peak and measuring at what gradient the maximum is measures.
The actual results show that the maxima are with the steepest
"""
module GradientGainDistributions

# import Pkg; Pkg.add(["JDF", "RollingFunctions"])
using DataFrames, Logging, Statistics
using Ohlcv, Features, Targets


"""
gainborders is a vector to map a price gain value to an array index and search function (Base.Sort.searchsortedfirst/searchsortedlast) to search index of a given gain or gradient.
"""
function preparegainborders(gainrange=0.1, gainstep=0.01)
    # gainrange = 0.1  # 10% = 0.1 considered OK to cover -5% .. +5% gain range
    # gainrange = 0.02  # 2% = 0.02 considered OK to decided about gradients for target label
    gainstep = 0.01
    gainborders = [g for g in (-gainrange / 2):gainstep:(gainrange / 2)]
    push!(gainborders, gainborders[end] * 1000)  # add very big gain that is surely not topped as last
    # println("gainborders=$gainborders  length(gainborders)=$(length(gainborders))")
    return gainborders
end

"""
regquantiles is a vector to map a regression gradient value to an array index and search function (Base.Sort.searchsortedfirst/searchsortedlast) to search index of a given gain or gradient.
"""
function prepareregquantiles(regressions, regbuckets=20)
    regstep = 1 / (regbuckets - 1)
    # println("regstep=$regstep")
    # regprobs = [rs for rs in (regstep/2):regstep:(1-regstep/2)]
    regprobs = [rs for rs in 0.0:regstep:1.0]
    println("regprobs=$regprobs")
    regquantiles::Array{Float32} = Statistics.quantile(skipmissing(regressions), regprobs)  # quantile border considers < vs. >=
    regquantiles[end] += eps(Float32)
    push!(regquantiles, regquantiles[end] * 100)  # add very big gradient that is surely not topped  as last
    # println("regquantiles=$regquantiles  length(regquantiles)=$(length(regquantiles))")
    return regquantiles
end

mutable struct RegressionHisto  # for long as well as short signals
    buyhisto::Array
    buylikelihoods::Array
    sellhisto::Array
    regquantiles::Array
    gainborders::Array
    longtrades::Bool  # true if long trades = up slopes else short trades = down slopes
    gainthreshold::Float32
    likelihoodthreshold::Float32
    buygradient::Float32
    sellgradient::Float32
    gradzeroix::Int
    gainzeroix::Int

    function RegressionHisto(regquantiles, gainborders, longtrades)
        regbuckets = length(regquantiles)
        "buyhisto and sellhisto are supplemented after each slope"
        bh = zeros(Int32, (regbuckets, length(gainborders)))  # used to register regression and gain of slope
        bcl = zeros(Float32, regbuckets)
        sh = zeros(Int32, regbuckets)  # only used to register the gradient of the best sell regression
        "gradgains is used to register all buy gradients of a single slope with their gains"
        gg = zeros(Union{Missing,Float32}, regbuckets)
        gradzix = searchsortedlast(regquantiles, 0 - eps(Float32)) + 1
        gainzix = searchsortedlast(gainborders, 0 - eps(Float32)) + 1
        new(bh, bcl, sh, regquantiles, gainborders, longtrades, 0.0, 0.0, 0.0, 0.0, gradzix, gainzix)
    end
end

function slope2histo!(histo, prices, regressions, buyix)
    gradgains::Array{Union{Missing,Float32}} = [missing for _ in 1:length(histo.buylikelihoods)]  # init gradient pair gains
    sellix = Features.nextextremeindex(regressions, buyix)
    if sellix == 0  # no extreme but the array end
        return histo, 0
    end
    sellix -= 1
    maxsellix = Targets.absmaxindex(prices, regressions, buyix, sellix)  # works for long and short trades

    regix = searchsortedlast(histo.regquantiles, regressions[maxsellix]) + 1
    histo.sellhisto[regix] += 1

    # println("buyix=$buyix, sellix=$sellix, maxsellix=$maxsellix")
    while buyix < sellix
        regix = searchsortedlast(histo.regquantiles, regressions[buyix]) + 1

        if regix == size(histo.regquantiles, 1)
            @warn "gradient > 100%" regressions[buyix] histo.regquantiles[end - 1]
        end

        if isequal(gradgains[regix], missing)  # only consider a gradient once in a particular slope
            gain = Ohlcv.relativegain(prices, buyix, sellix)
            gradgains[regix] = gain
            # println("gradgains[$sampleregix, $endregix] = $gain")
        end
        buyix += 1
    end
    for regix in 1:(length(histo.regquantiles))
        if !isequal(gradgains[regix], missing)
            gain = gradgains[regix]
            gainix = searchsortedlast(histo.gainborders, gain) + 1
            if gainix > size(histo.buyhisto, 2)
                gainix = size(histo.buyhisto, 2)
            end
            histo.buyhisto[regix, gainix] += 1
        end
    end
    return (histo, sellix + 1)
end

"""
Assumption: the probability for a successful trade signal is higher at a certain slope threshold but it is unclear where this threshold is.
This function shall collect all buy/sell gradients versus all of their potential counter sell/buy gradients versus the gain between them as a histogram
to identify the slope where a majority of gains is above 1% gain.
To achieve this the gradients as well as the gaps need to be split into buckets.
"""
function gradienthistogram(prices, regressions)
    @assert size(prices) == size(regressions) "sizes of prices and regressions shall match"
    gainborders = preparegainborders()
    regquantiles = prepareregquantiles(regressions)
    longhisto = RegressionHisto(regquantiles, gainborders, true)
    shorthisto = RegressionHisto(regquantiles, gainborders, false)

    buyix = Features.nextextremeindex(regressions, 1)
    while buyix != 0
        # println("buyix=$buyix, regressions[buyix]=$(regressions[buyix])")
        histo = regressions[buyix] > 0 ? longhisto : shorthisto
        histo, sellix = slope2histo!(histo, prices, regressions, buyix)
        buyix = sellix  # prepare for next slope (can be up or down)
    end
    return (longhisto, shorthisto)
end



"""
calculates the  likelihoods of gradients exceeding threshold gain, assuming that the likelihood increases with gradient
"""
function buygradientlikelihoods!(histo, gainthreshold)
    if histo.longtrades
        histo.gainthreshold = gainthreshold
        gainthresholdix = searchsortedlast(histo.gainborders, histo.gainthreshold) + 1
        for regix in 1:length(histo.buylikelihoods)
            allgains = sum(histo.buyhisto[regix, :])
            if allgains != 0
                gainsofinterest = sum(histo.buyhisto[regix, gainthresholdix:end])
                histo.buylikelihoods[regix] = gainsofinterest / allgains
            else
                histo.buylikelihoods[regix] = 0
            end
        end
    else  # short trades
        gainthreshold = -abs(gainthreshold)
        histo.gainthreshold = gainthreshold
        gainthresholdix = searchsortedlast(histo.gainborders, histo.gainthreshold) + 1
        llen = length(histo.buylikelihoods)
            for regix in llen:-1:1
            allgains = sum(histo.buyhisto[regix, :])
            if allgains != 0
                gainsofinterest = sum(histo.buyhisto[regix, 1:gainthresholdix])
                histo.buylikelihoods[regix] = gainsofinterest / allgains
            else
                histo.buylikelihoods[regix] = 0
            end
        end
    end
    return histo
end

function buyselltradegradients!(histo, gainthreshold, likelihoodthreshold)
    histo.likelihoodthreshold = likelihoodthreshold
    # println("2histo.gainthreshold=$histo.gainthreshold, histo.likelihoodthreshold=$histo.likelihoodthreshold")
    histo = buygradientlikelihoods!(histo, gainthreshold)
    if histo.longtrades
        buygradientix = length(histo.buylikelihoods)  # worst case
        for ix in 1:length(histo.buylikelihoods)
            if histo.buylikelihoods[ix] >= likelihoodthreshold
                buygradientix = ix
                break  # all steeper gradients are assumed to be even more likely to gain the threshold
            end
        end
    else  # short trades
        buygradientix = 1  # worst case
        for ix in length(histo.buylikelihoods):-1:1
            if histo.buylikelihoods[ix] >= likelihoodthreshold
                buygradientix = ix
                break  # all steeper gradients are assumed to be even more likely to gain the threshold
            end
        end
    end
    if buygradientix > length(histo.regquantiles)
        @warn "buygradientix > length(histo.regquantiles)" buygradientix  length(histo.regquantiles)
        buygradientix = length(histo.regquantiles)
    end
    histo.buygradient = histo.regquantiles[buygradientix]
    _, sellgradientix = findmax(histo.sellhisto)
    histo.sellgradient = histo.regquantiles[sellgradientix]
    # return histo.buygradient, histo.sellgradient
    return histo
end

"""
identifies highest likelihood start/end regression gradient independent of each other
The result is part of the returned struct that also provides many intermediate results.
"""
function tradegradienthisto(prices, regressions, gainthreshold=Targets.gainthreshold, likelihoodthreshold=Targets.gainlikelihoodthreshold)
    longhisto, shorthisto = gradienthistogram(prices, regressions)

    longhisto = buyselltradegradients!(longhisto, gainthreshold, likelihoodthreshold)
    shorthisto = buyselltradegradients!(shorthisto, gainthreshold, likelihoodthreshold)
    return longhisto, shorthisto
end

"""
identifies highest likelihood start/end regression gradient independent of each other
"""
function tradegradientthresholds(prices, regressions, gainthreshold=Targets.gainthreshold, likelihoodthreshold=Targets.gainlikelihoodthreshold)
    longhisto, shorthisto = tradegradienthisto(prices, regressions, gainthreshold, likelihoodthreshold)
    return longhisto.buygradient, longhisto.sellgradient, shorthisto.buygradient, shorthisto.sellgradient
end

end

module GradientGainDistributionsTest

# import Pkg; Pkg.add(["JDF", "RollingFunctions"])
using Test, DataFrames, Logging, NamedArrays
using EnvConfig, Ohlcv, TestOhlcv, Features, Targets, ..GradientGainDistributions

EnvConfig.init(test)
EnvConfig.init(production)
println("\nconfig mode = $(EnvConfig.configmode)")

#=
This file is part of target_test.jl =#


function prettyprint(histo)
    println("histo struct: $histo")
    # display(histo)
    # println("histo.buyhisto array:")
    # display(NamedArray(histo.buyhisto, ( histo.regquantiles, histo.gainborders ), ("gradients", "gains")))
    # display(histo.buyhisto)
    # println("histo.buyikelihoods array:")
    # display(NamedArray(histo.buylikelihoods, histo.regquantiles))
    # display(histo.buylikelihoods)
    println("histo.sellhisto array:")
    display(NamedArray(histo.sellhisto, histo.regquantiles, "gradients"))
    # display(histo.sellhisto)
    # println("histo.regquantiles array:")
    # display(histo.regquantiles)
    # println("histo.gainborders array:")
    # display(histo.gainborders)
    println("")
end

function tradegradienthisto_test()
    ohlcv = TestOhlcv.doublesinedata(40, 2)
    regr5 = Features.normrollingregression(ohlcv.df.pivot, 5)
    longhisto, shorthisto = GradientGainDistributions.tradegradienthisto(ohlcv.df.pivot, regr5)
    prettyprint(longhisto)
    prettyprint(shorthisto)
    return longhisto, shorthisto
end

function gradientdistributions()
    for base in EnvConfig.trainingbases
    # base = "xrp"
        @info "reading ohlcv" base
        ohlcv = Ohlcv.read(base)
        regr5 = Features.normrollingregression(ohlcv.df.pivot, 5)
        longhisto, shorthisto = GradientGainDistributions.tradegradienthisto(ohlcv.df.pivot, regr5)
        prettyprint(longhisto)
        prettyprint(shorthisto)
    end
end

# tradegradienthisto_test()
gradientdistributions()

@testset "Targets gradient gain distribution tests" begin

    ohlcv = TestOhlcv.doublesinedata(40, 2)
    regressions = Features.normrollingregression(ohlcv.df.pivot, 5)
    longhisto, shorthisto = GradientGainDistributions.tradegradienthisto(ohlcv.df.pivot, regressions, 0.01, 0.5)
    @test isapprox(longhisto.buygradient, 0.0003251453f0)
    @test isapprox(longhisto.sellgradient, 0.0003251453f0)
    @test isapprox(shorthisto.buygradient, 0.0f0)
    @test isapprox(shorthisto.sellgradient, -0.0006773857f0)
    longstartregr, longendregr, shortstartregr, shortendregr = GradientGainDistributions.tradegradientthresholds(ohlcv.df.pivot, regressions, 0.01, 0.5)
    @test isapprox(longstartregr, 0.0003251453f0, )
    @test isapprox(longendregr, 0.0003251453f0)
    @test isapprox(shortstartregr, 0.0f0)
    @test isapprox(shortendregr, -0.0006773857f0)

end  # of testset


end
